//======================================================================
// QUY·ªÄN L·ª∞C B√ìNG T·ªêI - SERVER LOGIC (T∆Ø∆†NG TH√çCH HO√ÄN TO√ÄN V·ªöI HOSTING)
//======================================================================

const express = require('express');
const http = require('http');
const path = require('path');
const { Server } = require("socket.io");

const app = express();
const server = http.createServer(app);
const io = new Server(server);

// [S·ª¨A L·ªñI HOSTING QUAN TR·ªåNG]
// D√≤ng n√†y y√™u c·∫ßu Express ph·ª•c v·ª• c√°c file tƒ©nh (CSS, JS, √Çm thanh)
// ngay t·∫°i th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n tr√™n Render.
app.use(express.static(path.join(__dirname)));

// [S·ª¨A L·ªñI HOSTING QUAN TR·ªåNG]
// Khi c√≥ ai ƒë√≥ truy c·∫≠p trang ch·ªß, server s·∫Ω g·ª≠i l·∫°i file index.html
// c≈©ng n·∫±m ·ªü th∆∞ m·ª•c g·ªëc.
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

// Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ tr·∫°ng th√°i c√°c ph√≤ng ch∆°i
const rooms = {};

// ... TO√ÄN B·ªò LOGIC GAME V√Ä S·∫ÆC L·ªÜNH C·ª¶A B·∫†N N·∫∞M ·ªû ƒê√ÇY ...
// (Ph·∫ßn logic c√≤n l·∫°i gi·ªëng h·ªát phi√™n b·∫£n tr∆∞·ªõc, kh√¥ng c·∫ßn thay ƒë·ªïi)
const CHOICE_DURATION = 30; const CHAOS_DURATION = 30; const DECREE_REVEAL_DELAY = 5000; const WIN_SCORE = 15; const LOSE_SCORE = -15;
const DECREES = { "NHAN_DOI": { name: "Ng√†y Nh√¢n ƒê√¥i", description: "T·∫•t c·∫£ ƒëi·ªÉm c·ªông v√† tr·ª´ trong v√≤ng n√†y s·∫Ω ƒë∆∞·ª£c nh√¢n ƒë√¥i!", getPointMultiplier: () => 2 }, "GIO_GIOI_NGHIEM": { name: "Gi·ªù Gi·ªõi Nghi√™m", description: "V√≤ng n√†y c·∫•m m·ªçi h√†nh vi Th√°ch ƒê·∫•u v√† Gh√©p ƒê·ªôi.", isChaosDisabled: true }, "DAO_NGUOC": { name: "Ng√†y Ph√°n X√©t ƒê·∫£o Ng∆∞·ª£c", description: "Phe c√≥ NHI·ªÄU phi·∫øu h∆°n s·∫Ω l√† phe chi·∫øn th·∫Øng!", determineWinner: (c, t) => (c === t ? null : (c > t ? 'C·ªëng Hi·∫øn' : 'Tham Nh≈©ng')) }, "THUE_THAN": { name: "Thu·∫ø Th√¢n", description: "Cu·ªëi v√≤ng, ng∆∞·ªùi c√≥ ƒëi·ªÉm cao nh·∫•t b·ªã -2, ng∆∞·ªùi th·∫•p nh·∫•t ƒë∆∞·ª£c +2.", endOfRoundEffect: (gs, results, pointMultiplier) => { const highestPlayers = getPlayersByScore(gs.players, 'highest'); const lowestPlayers = getPlayersByScore(gs.players, 'lowest'); if (highestPlayers.length > 0 && lowestPlayers.length > 0 && highestPlayers[0].id !== lowestPlayers[0].id) { const tax = 2 * pointMultiplier * highestPlayers.length; highestPlayers.forEach(p => p.score -= (2 * pointMultiplier)); lowestPlayers.forEach(p => p.score += tax / lowestPlayers.length); results.messages.push(`üìú **Thu·∫ø Th√¢n** ƒë∆∞·ª£c √°p d·ª•ng! ${tax} ƒëi·ªÉm ƒë√£ ƒë∆∞·ª£c chuy·ªÉn giao.`); } } }, "LOI_THI_THAM_CUA_QUY": { name: "L·ªùi Th√¨ Th·∫ßm C·ªßa Qu·ª∑", description: "Ho√°n ƒë·ªïi l·ª±a ch·ªçn c·ªßa m·ªçi ng∆∞·ªùi theo v√≤ng tr√≤n.", isChaosDisabled: true, onReveal: (gs, io, roomCode) => { const active = gs.players.filter(p => !p.isDefeated && p.chosenAction); if (active.length < 2) return; const choices = active.map(p => p.chosenAction); for (let i = 0; i < active.length; i++) { active[i].chosenAction = choices[(i === 0) ? active.length - 1 : i - 1]; } io.to(roomCode).emit('actionsSwapped', { message: "üòà L·ª±a ch·ªçn c·ªßa m·ªçi ng∆∞·ªùi ƒë√£ b·ªã ho√°n ƒë·ªïi!" }); } }, "AMNESIA_DAY": { name: "Ng√†y M·∫•t Tr√≠", description: "Ng∆∞·ªùi th·∫•p ƒëi·ªÉm nh·∫•t ho√°n ƒë·ªïi l·ª±a ch·ªçn c·ªßa 2 ng∆∞·ªùi.", onReveal: (gs, io, roomCode, drawerId) => { gs.phase = 'special_action'; const drawer = gs.players.find(p => p.id === drawerId); io.to(drawerId).emit('promptAmnesiaAction', { players: gs.players.map(p => ({ id: p.id, name: p.name })) }); io.to(roomCode).except(drawerId).emit('logMessage', { type: 'warning', message: `üß† ƒêang ch·ªù ${drawer.name} th·ª±c hi·ªán quy·ªÅn nƒÉng...`}); } }, };
const DECREE_IDS = Object.keys(DECREES);
function createGameState(players) { const gameState = { players: players.map(p => ({ ...p, score: 0, chosenAction: null, isDefeated: false, disconnected: false })), currentRound: 0, winScore: WIN_SCORE, loseScore: LOSE_SCORE, phase: 'waiting', roundData: {} }; shuffleDecreeDeck(gameState); return gameState; }
function shuffleDecreeDeck(gs) { gs.decreeDeck = [...DECREE_IDS]; for (let i = gs.decreeDeck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [gs.decreeDeck[i], gs.decreeDeck[j]] = [gs.decreeDeck[j], gs.decreeDeck[i]]; } gs.decreeDiscard = []; }
function startNewRound(roomCode) { const room = rooms[roomCode]; if (!room || !room.gameState) return; const gs = room.gameState; gs.currentRound++; gs.phase = 'choice'; gs.players.forEach(p => { if (!p.isDefeated) p.chosenAction = null; }); gs.roundData = { decree: null, chaosActionTaken: false, chaosResult: null, chaosTimer: null, drawerId: null, votesToSkip: new Set(), choiceTimer: null }; io.to(roomCode).emit('newRound', { roundNumber: gs.currentRound, players: gs.players.map(({ id, name, score, isDefeated, disconnected }) => ({ id, name, score, isDefeated, disconnected })), duration: CHOICE_DURATION }); gs.roundData.choiceTimer = setTimeout(() => { gs.players.forEach(p => { if (!p.chosenAction && !p.isDefeated) { const choices = ['C·ªëng Hi·∫øn', 'Tham Nh≈©ng', 'Phi·∫øu Tr·ªëng']; const randomChoice = choices[Math.floor(Math.random() * 3)]; handlePlayerChoice(roomCode, p.id, randomChoice); } }); }, CHOICE_DURATION * 1000); triggerBotChoices(roomCode); }
function revealDecreeAndContinue(roomCode) { const gs = rooms[roomCode].gameState; gs.phase = 'decree'; if (gs.currentRound === 1) { io.to(roomCode).emit('logMessage', { type: 'info', message: "V√≤ng 1 kh√¥ng c√≥ S·∫Øc L·ªánh." }); startChaosPhase(roomCode); return; } if (gs.decreeDeck.length === 0) { shuffleDecreeDeck(gs); } const lowest = getPlayersByScore(gs.players, 'lowest'); const drawer = lowest[Math.floor(Math.random() * lowest.length)]; gs.roundData.drawerId = drawer.id; const decreeId = gs.decreeDeck.pop(); gs.decreeDiscard.push(decreeId); gs.roundData.decree = { ...DECREES[decreeId], id: decreeId }; io.to(roomCode).emit('decreeRevealed', { drawerName: drawer.name, decree: { name: gs.roundData.decree.name, description: gs.roundData.decree.description } }); setTimeout(() => { let continueToChaos = true; if (gs.roundData.decree.onReveal) { gs.roundData.decree.onReveal(gs, io, roomCode, drawer.id); if (gs.phase === 'special_action') { continueToChaos = false; } } if (continueToChaos) { startChaosPhase(roomCode); } }, DECREE_REVEAL_DELAY); }
function startChaosPhase(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; if (gs.roundData.decree?.isChaosDisabled) { endChaosPhase(roomCode, `S·∫Øc l·ªánh '${gs.roundData.decree.name}' c·∫•m Giai ƒêo·∫°n H·ªón Lo·∫°n!`); return; } gs.phase = 'chaos'; io.to(roomCode).emit('chaosPhaseStarted', { duration: CHAOS_DURATION }); gs.roundData.chaosTimer = setTimeout(() => endChaosPhase(roomCode, "H·∫øt gi·ªù, kh√¥ng c√≥ h√†nh ƒë·ªông n√†o di·ªÖn ra."), CHAOS_DURATION * 1000); triggerBotChaosAction(roomCode); }
function endChaosPhase(roomCode, message) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.roundData.chaosActionTaken) return; gs.roundData.chaosActionTaken = true; gs.phase = 'reveal_pending'; clearTimeout(gs.roundData.chaosTimer); io.to(roomCode).emit('chaosActionResolved', { message }); setTimeout(() => calculateScoresAndEndRound(roomCode), 3000); }
function calculateScoresAndEndRound(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; gs.phase = 'reveal'; const { decree, chaosResult } = gs.roundData; const results = { messages: [], scoreChanges: {}, isDraw: false, winner: null }; const pointMultiplier = decree?.getPointMultiplier?.() || 1; const active = gs.players.filter(p => !p.isDefeated); if (active.length === 0) return; const votes = { 'C·ªëng Hi·∫øn': 0, 'Tham Nh≈©ng': 0, 'Phi·∫øu Tr·ªëng': 0 }; active.forEach(p => { if (p.chosenAction) votes[p.chosenAction]++; }); if (chaosResult?.success && chaosResult.actionType === 'teamup') { if (votes[chaosResult.actionToReduce] > 0) { votes[chaosResult.actionToReduce]--; results.messages.push("ü§ù Gh√©p ƒê·ªôi th√†nh c√¥ng, m·ªôt phi·∫øu ƒë∆∞·ª£c lo·∫°i b·ªè!"); } } const { 'C·ªëng Hi·∫øn': c, 'Tham Nh≈©ng': t, 'Phi·∫øu Tr·ªëng': pt } = votes; const totalVotes = c + t + pt; let isDraw = false; if ((c === t && c > 0) || (active.length > 1 && (c === totalVotes || t === totalVotes)) || (pt > 0 && c === 0 && t === 0) || (pt > 0 && totalVotes === pt + c && t === 0) || (pt > 0 && totalVotes === pt + t && c === 0)) isDraw = true; let winner = null; if (isDraw) results.messages.push("‚öñÔ∏è K·∫øt qu·∫£: **H√íA**!"); else { winner = decree?.determineWinner ? decree.determineWinner(c, t) : (c < t ? 'C·ªëng Hi·∫øn' : 'Tham Nh≈©ng'); if (decree?.determineWinner) results.messages.push(`üìú S·∫Øc l·ªánh '${decree.name}' c√≥ hi·ªáu l·ª±c!`); results.messages.push(`Phe **${winner}** ƒë√£ chi·∫øn th·∫Øng!`); } active.forEach(p => { let change = 0; if (isDraw) change = pt > 0 ? (p.chosenAction === 'Phi·∫øu Tr·ªëng' ? -1 : 1) : -1; else if (p.chosenAction === winner) change = 2; else if (p.chosenAction === 'Phi·∫øu Tr·ªëng') change = 3; const final = change * pointMultiplier; p.score += final; results.scoreChanges[p.id] = final; }); gs.roundData.lastScoreChanges = results.scoreChanges; io.to(roomCode).emit('roundResult', { players: gs.players, results, finalVoteCounts: votes }); triggerRandomEvent(roomCode); const W = gs.players.filter(p => p.score >= WIN_SCORE), L = gs.players.filter(p => p.score <= LOSE_SCORE); if (W.length > 0 || L.length > 0) { gs.phase = 'gameover'; io.to(roomCode).emit('gameOver', { winner: W[0], loser: L[0] }); } else io.to(rooms[roomCode].hostId).emit('promptNextRound'); }
function getPlayersByScore(players, type) { const a = players.filter(p => !p.isDefeated && !p.disconnected); if (a.length === 0) return []; const s = a.map(p => p.score); const c = type === 'highest' ? Math.max(...s) : Math.min(...s); return a.filter(p => p.score === c); }
function handlePlayerChoice(roomCode, playerId, choice) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'choice') return; const p = gs.players.find(p => p.id === playerId); if (p && !p.chosenAction) { p.chosenAction = choice; io.to(roomCode).emit('playerChose', playerId); } if (gs.players.filter(p => !p.isDefeated).every(p => p.chosenAction)) { clearTimeout(gs.roundData.choiceTimer); revealDecreeAndContinue(roomCode); } }
function handleChaosAction(roomCode, initiatorId, targetId, actionType, guess = null) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const i = gs.players.find(p => p.id === initiatorId), t = gs.players.find(p => p.id === targetId); if (!i || !t) return; let msg = ""; const multi = gs.roundData.decree?.getPointMultiplier?.() || 1; if (actionType === 'challenge') { const success = guess === t.chosenAction; msg = `üî• **${i.name}** ƒë√£ Th√°ch ƒê·∫•u **${t.name}** v√† ${success ? "ƒëo√°n **ƒê√öNG**" : "ƒëo√°n **SAI**"}!`; const change = 2 * multi; if (success) { i.score += change; t.score -= change; } else { i.score -= change; t.score += change; } } else if (actionType === 'teamup') { const success = i.chosenAction === t.chosenAction; msg = `ü§ù **${i.name}** ƒë√£ Gh√©p ƒê·ªôi v·ªõi **${t.name}** v√† ${success ? "**th√†nh c√¥ng**" : "**th·∫•t b·∫°i**"}!`; if (success) gs.roundData.chaosResult = { actionType, success, actionToReduce: i.chosenAction }; else i.score -= multi; } endChaosPhase(roomCode, msg); }
function triggerRandomEvent(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs || Math.random() > 0.20) return; const events = ['avenger', 'treasury_empty']; const randomEvent = events[Math.floor(Math.random() * events.length)]; let message = ""; if (randomEvent === 'avenger') { let maxLoser = null; let maxLoss = 0; for (const id in gs.roundData.lastScoreChanges) { if (gs.roundData.lastScoreChanges[id] < maxLoss) { maxLoss = gs.roundData.lastScoreChanges[id]; maxLoser = gs.players.find(p => p.id === id); } } if (maxLoser) { maxLoser.score += 2; message = `‚öîÔ∏è **Th√≠ch Kh√°ch B√°o Th√π!** ${maxLoser.name} b·ªã tr·ª´ nhi·ªÅu ƒëi·ªÉm nh·∫•t v√† ƒë∆∞·ª£c ban th∆∞·ªüng 2 ƒëi·ªÉm an ·ªßi!`; } } else if (randomEvent === 'treasury_empty') { gs.players.forEach(p => p.score--); message = `üìâ **Ng√¢n Kh·ªë R·ªóng Tu·∫øch!** Do kh·ªßng ho·∫£ng, t·∫•t c·∫£ ng∆∞·ªùi ch∆°i b·ªã tr·ª´ 1 ƒëi·ªÉm!`; } if (message) { io.to(roomCode).emit('logMessage', { type: 'warning', message }); io.to(roomCode).emit('updateScores', gs.players.map(p => ({ id: p.id, score: p.score }))); } }
function triggerBotChoices(roomCode) { rooms[roomCode]?.gameState?.players.forEach(p => { if (p.isBot && !p.isDefeated) setTimeout(() => { if (!p.chosenAction) { let choice; switch(p.personality) { case 'aggressive': choice = Math.random() < 0.7 ? 'Tham Nh≈©ng' : 'C·ªëng Hi·∫øn'; break; case 'cautious': choice = Math.random() < 0.75 ? 'C·ªëng Hi·∫øn' : 'Phi·∫øu Tr·ªëng'; break; default: choice = ['C·ªëng Hi·∫øn', 'Tham Nh≈©ng', 'Phi·∫øu Tr·ªëng'][Math.floor(Math.random() * 3)]; } handlePlayerChoice(roomCode, p.id, choice); } }, Math.random() * 2000 + 1500); }); }
function triggerBotChaosAction(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; const bots = gs.players.filter(p => p.isBot && !p.isDefeated); const targets = gs.players.filter(p => !p.isDefeated); if (bots.length === 0 || targets.length < 2) return; bots.forEach(bot => { setTimeout(() => { if (gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const candidates = targets.filter(p => p.id !== bot.id); if (candidates.length === 0) return; const target = candidates[Math.floor(Math.random() * candidates.length)]; const actionProbability = bot.personality === 'aggressive' ? 0.6 : (bot.personality === 'cautious' ? 0.3 : 0.4); if (Math.random() < actionProbability) { const actionType = (bot.personality === 'cautious' && Math.random() < 0.8) ? 'teamup' : 'challenge'; if (actionType === 'challenge') { const guess = ['C·ªëng Hi·∫øn', 'Tham Nh≈©ng', 'Phi·∫øu Tr·ªëng'][Math.floor(Math.random() * 3)]; handleChaosAction(roomCode, bot.id, target.id, 'challenge', guess); } else { handleChaosAction(roomCode, bot.id, target.id, 'teamup'); } } else if (Math.random() < 0.5) { socket.emit('playerVotedToSkip', roomCode, bot.id); } }, Math.random() * 10000 + 5000); }); }
io.on('connection', (socket) => { socket.on('createRoom', data => { let code; do { code = Math.random().toString(36).substring(2, 6).toUpperCase(); } while (rooms[code]); rooms[code] = { players: [], hostId: socket.id, maxPlayers: 12, gameState: null }; handleJoinRoom(code, data.name); }); socket.on('joinRoom', data => handleJoinRoom(data.roomCode?.trim().toUpperCase(), data.name)); function handleJoinRoom(code, name) { const room = rooms[code]; if (!room) return socket.emit('roomError', `Ph√≤ng '${code}' kh√¥ng t·ªìn t·∫°i!`); if (room.gameState) return socket.emit('roomError', 'Tr√≤ ch∆°i ƒë√£ b·∫Øt ƒë·∫ßu!'); if (room.players.length >= room.maxPlayers) return socket.emit('roomError', 'Ph√≤ng ƒë√£ ƒë·∫ßy!'); const p = { id: socket.id, name: (name || `Ng∆∞·ªùi ch∆°i ${room.players.length + 1}`).substring(0, 15).trim(), isBot: false }; room.players.push(p); socket.join(code); io.to(code).emit('updatePlayerList', room.players, room.hostId); socket.emit('joinedRoom', { roomCode: code, hostId: room.hostId, myId: socket.id, players: room.players }); } socket.on('addBot', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.players.length < r.maxPlayers) { const personalities = ['aggressive', 'cautious', 'random']; const p = { id: `bot-${Date.now()}`, name: `Bot ${r.players.length + 1}`, isBot: true, personality: personalities[Math.floor(Math.random() * personalities.length)] }; r.players.push(p); io.to(code).emit('updatePlayerList', r.players, r.hostId); } }); socket.on('kickPlayer', (data) => { const room = rooms[data.roomCode]; if (room && socket.id === room.hostId) { const targetSocket = io.sockets.sockets.get(data.playerId); if (targetSocket) { targetSocket.emit('kicked'); targetSocket.leave(data.roomCode); } room.players = room.players.filter(p => p.id !== data.playerId); io.to(data.roomCode).emit('updatePlayerList', room.players, room.hostId); } }); socket.on('changeName', data => { const p = rooms[data.roomCode]?.players.find(p => p.id === socket.id); if (p) { p.name = data.newName.substring(0, 15).trim() || p.name; io.to(data.roomCode).emit('updatePlayerList', rooms[data.roomCode].players, rooms[data.roomCode].hostId); } }); socket.on('startGame', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.players.length >= 2) { r.gameState = createGameState(r.players); io.to(code).emit('gameStarted'); startNewRound(code); } }); socket.on('playerChoice', data => handlePlayerChoice(data.roomCode, socket.id, data.choice)); socket.on('requestChaosAction', data => handleChaosAction(data.roomCode, socket.id, data.targetId, data.actionType, data.guess)); socket.on('playerVotedToSkip', (roomCode, botId = null) => { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const voterId = botId || socket.id; gs.roundData.votesToSkip.add(voterId); const totalPlayers = gs.players.filter(p => !p.disconnected).length; io.to(roomCode).emit('updateSkipVoteCount', gs.roundData.votesToSkip.size, totalPlayers); if (gs.roundData.votesToSkip.size >= totalPlayers) { endChaosPhase(roomCode, "T·∫•t c·∫£ ng∆∞·ªùi ch∆°i ƒë√£ ƒë·ªìng √Ω b·ªè qua giai ƒëo·∫°n n√†y."); } }); socket.on('amnesiaAction', data => { const gs = rooms[data.roomCode]?.gameState; if (!gs || gs.phase !== 'special_action') return; const p1 = gs.players.find(p => p.id === data.player1Id), p2 = gs.players.find(p => p.id === data.player2Id); if (p1 && p2) { [p1.chosenAction, p2.chosenAction] = [p2.chosenAction, p1.chosenAction]; io.to(data.roomCode).emit('logMessage', { type: 'warning', message: `üß† L·ª±a ch·ªçn c·ªßa **${p1.name}** v√† **${p2.name}** ƒë√£ b·ªã ho√°n ƒë·ªïi!` }); } startChaosPhase(data.roomCode); }); socket.on('nextRound', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.gameState.phase !== 'gameover') startNewRound(code); }); socket.on('playAgain', (roomCode) => { const room = rooms[code]; if (room && socket.id === room.hostId && room.gameState.phase === 'gameover') { room.gameState = createGameState(room.players); io.to(roomCode).emit('gameStarted'); startNewRound(roomCode); } }); socket.on('disconnect', () => { for (const code in rooms) { const r = rooms[code]; const i = r.players.findIndex(p => p.id === socket.id); if (i !== -1) { if (r.gameState) { const p = r.gameState.players.find(p => p.id === socket.id); if (p) { p.disconnected = true; p.name = `${p.name} (R·ªùi tr·∫≠n)`; io.to(code).emit('playerDisconnected', { playerId: socket.id, newName: p.name }); } } else r.players.splice(i, 1); if (r.players.filter(p => !p.isBot).length === 0) { delete rooms[code]; break; } if (socket.id === r.hostId && r.players.length > 0) { r.hostId = (r.players.find(p => !p.isBot) || r.players[0]).id; } io.to(code).emit('updatePlayerList', r.players, r.hostId); break; } } }); });


// Kh·ªüi ƒë·ªông server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`[SERVER] M√°y ch·ªß ƒëang l·∫Øng nghe tr√™n c·ªïng ${PORT}`);
});