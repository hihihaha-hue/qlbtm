//======================================================================
// QUY·ªÄN L·ª∞C B√ìNG T·ªêI - SERVER LOGIC (FULL BOT TH√îNG MINH)
//======================================================================

const express = require('express');
const http = require('http');
const path = require('path');
const { Server } = require("socket.io");

const app = express();
const server = http.createServer(app);
const io = new Server(server, { pingInterval: 10000, pingTimeout: 5000 });
const publicPath = path.join(__dirname, 'public');
app.use(express.static(publicPath));
const rooms = {};

const CHAOS_DURATION = 30; const DECREE_REVEAL_DELAY = 5000; const WIN_SCORE = 15; const LOSE_SCORE = -15;

// [N√ÇNG C·∫§P] K√≠ch ho·∫°t v√† l·∫≠p tr√¨nh logic cho c√°c S·∫Øc L·ªánh ph·ª©c t·∫°p
const DECREES = {
    "NGAY_NHAN_DOI": { name: "Ng√†y Nh√¢n ƒê√¥i", description: "T·∫•t c·∫£ ƒëi·ªÉm c·ªông v√† tr·ª´ trong v√≤ng n√†y s·∫Ω ƒë∆∞·ª£c nh√¢n ƒë√¥i!", getPointMultiplier: () => 2 },
    "GIO_GIOI_NGHIEM": { name: "Gi·ªù Gi·ªõi Nghi√™m", description: "V√≤ng n√†y c·∫•m m·ªçi h√†nh vi Th√°ch ƒê·∫•u v√† Gh√©p ƒê·ªôi.", isChaosDisabled: true },
    "NGAY_PHAN_XET_DAO_NGUOC": { name: "Ng√†y Ph√°n X√©t ƒê·∫£o Ng∆∞·ª£c", description: "Phe c√≥ NHI·ªÄU phi·∫øu h∆°n s·∫Ω l√† phe chi·∫øn th·∫Øng!", determineWinner: (c, t) => (c === t ? null : (c > t ? 'C·ªëng Hi·∫øn' : 'Tham Nh≈©ng')) },
    "THUE_THAN": { name: "Thu·∫ø Th√¢n", description: "Cu·ªëi v√≤ng, ng∆∞·ªùi cao ƒëi·ªÉm nh·∫•t -2 ƒëi·ªÉm, s·ªë ƒëi·ªÉm ƒë√≥ ƒë∆∞·ª£c c·ªông cho ng∆∞·ªùi th·∫•p ƒëi·ªÉm nh·∫•t.", endOfRoundEffect: (gs, results, pointMultiplier) => { const h = getPlayersByScore(gs.players, 'highest'); const l = getPlayersByScore(gs.players, 'lowest'); if (h.length > 0 && l.length > 0 && h[0].id !== l[0].id) { const tax = 2 * pointMultiplier; h.forEach(p => p.score -= tax); l.forEach(p => p.score += tax * h.length / l.length); results.messages.push(`üìú **Thu·∫ø Th√¢n** ƒë∆∞·ª£c √°p d·ª•ng!`); } } },
    "LOI_THI_THAM_CUA_QUY": { name: "L·ªùi Th√¨ Th·∫ßm C·ªßa Qu·ª∑", description: "Ho√°n ƒë·ªïi l·ª±a ch·ªçn c·ªßa m·ªçi ng∆∞·ªùi theo v√≤ng tr√≤n.", isChaosDisabled: true, onReveal: (gs, io, roomCode) => { const a = gs.players.filter(p => !p.isDefeated && p.chosenAction); if (a.length < 2) return; const c = a.map(p => p.chosenAction); for (let i = 0; i < a.length; i++) { a[i].chosenAction = c[(i === 0) ? a.length - 1 : i - 1]; } io.to(roomCode).emit('actionsSwapped', { message: "üòà L·ª±a ch·ªçn c·ªßa m·ªçi ng∆∞·ªùi ƒë√£ b·ªã ho√°n ƒë·ªïi!" }); } },
    "AMNESIA_DAY": { name: "Ng√†y M·∫•t Tr√≠", description: "Ng∆∞·ªùi th·∫•p ƒëi·ªÉm nh·∫•t ho√°n ƒë·ªïi l·ª±a ch·ªçn c·ªßa 2 ng∆∞·ªùi.", onReveal: (gs, io, roomCode, drawerId) => {
        const drawer = gs.players.find(p => p.id === drawerId);
        if (drawer.isBot) handleBotAmnesia(roomCode, drawerId);
        else { gs.phase = 'special_action'; io.to(drawerId).emit('promptAmnesiaAction', { players: gs.players.map(p => ({ id: p.id, name: p.name })) }); io.to(roomCode).except(drawerId).emit('logMessage', { type: 'warning', message: `üß† ƒêang ch·ªù ${drawer.name} th·ª±c hi·ªán quy·ªÅn nƒÉng...`}); }
    } },
    "DAU_TRUONG_LA_MA": { name: "ƒê·∫•u Tr∆∞·ªùng La M√£", description: "Ng∆∞·ªùi th·∫•p ƒëi·ªÉm nh·∫•t ch·ªçn 2 ƒê·∫•u Sƒ©. Kh√°n gi·∫£ ƒë·∫∑t c∆∞·ª£c ƒëi·ªÉm.", onReveal: (gs, io, roomCode, drawerId) => {
        const drawer = gs.players.find(p => p.id === drawerId);
        if (drawer.isBot) handleBotRomanArena(roomCode, drawerId);
        else { gs.phase = 'special_action'; io.to(drawerId).emit('promptRomanArenaAction', { players: gs.players.map(p => ({ id: p.id, name: p.name })) }); io.to(roomCode).except(drawerId).emit('logMessage', { type: 'warning', message: `‚öîÔ∏è ƒêang ch·ªù ${drawer.name} ch·ªçn ra 2 ƒê·∫•u Sƒ©...`}); }
    } },
    "DI_SAN_CUA_KE_THANG": { name: "Di S·∫£n C·ªßa K·∫ª Th·∫Øng", description: "Ng∆∞·ªùi th·∫Øng v√≤ng n√†y ƒë∆∞·ª£c ch·ªçn S·∫Øc L·ªánh cho v√≤ng sau t·ª´ 3 l√° ng·∫´u nhi√™n." },
    "NGAY_SONG_TRUNG": { name: "Ng√†y Song Tr√πng", description: "Ng∆∞·ªùi b·ªëc ƒë∆∞·ª£c s·∫Ω b·ªëc th√™m 1 S·∫Øc L·ªánh n·ªØa, √°p d·ª•ng c·∫£ 2 trong v√≤ng n√†y." },
};

const ALL_DECREE_IDS = Object.keys(DECREES);

// ... c√°c h√†m logic kh√°c gi·ªØ nguy√™n ...
function createGameState(players) { const gameState = { players: players.map(p => ({ ...p, score: 0, chosenAction: null, isDefeated: false, disconnected: false })), currentRound: 0, winScore: WIN_SCORE, loseScore: LOSE_SCORE, phase: 'waiting', roundData: {}, decreeDeck: [], decreeDiscard: [], nextDecree: null }; shuffleDecreeDeck(gameState); return gameState; }
function shuffleDecreeDeck(gs) { gs.decreeDeck = [...ALL_DECREE_IDS]; for (let i = gs.decreeDeck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [gs.decreeDeck[i], gs.decreeDeck[j]] = [gs.decreeDeck[j], gs.decreeDeck[i]]; } gs.decreeDiscard = []; }
function startNewRound(roomCode) { const room = rooms[roomCode]; if (!room || !room.gameState) return; const gs = room.gameState; gs.currentRound++; gs.phase = 'choice'; gs.players.forEach(p => { if (!p.isDefeated) p.chosenAction = null; }); gs.roundData = { decrees: [], chaosActionTaken: false, chaosResult: null, chaosTimer: null, drawerId: null, votesToSkip: new Set(), choiceTimer: null }; io.to(roomCode).emit('newRound', { roundNumber: gs.currentRound, players: gs.players.map(({ id, name, score, isDefeated, disconnected }) => ({ id, name, score, isDefeated, disconnected })), duration: 30 }); gs.roundData.choiceTimer = setTimeout(() => { gs.players.forEach(p => { if (!p.chosenAction && !p.isDefeated) { const choices = ['C·ªëng Hi·∫øn', 'Tham Nh≈©ng', 'Phi·∫øu Tr·ªëng']; const randomChoice = choices[Math.floor(Math.random() * choices.length)]; handlePlayerChoice(roomCode, p.id, randomChoice); } }); }, 30 * 1000); triggerBotChoices(roomCode); }
function revealDecreeAndContinue(roomCode) { const gs = rooms[roomCode].gameState; gs.phase = 'decree'; if (gs.currentRound === 1) { io.to(roomCode).emit('logMessage', { type: 'info', message: "V√≤ng 1 kh√¥ng c√≥ S·∫Øc L·ªánh." }); startChaosPhase(roomCode); return; } if (gs.decreeDeck.length < 3) shuffleDecreeDeck(gs); const lowest = getPlayersByScore(gs.players, 'lowest'); const drawer = lowest[Math.floor(Math.random() * lowest.length)]; gs.roundData.drawerId = drawer.id; let decreesToReveal = []; if (gs.nextDecree) { decreesToReveal.push(gs.nextDecree); gs.nextDecree = null; } else { const decreeId = gs.decreeDeck.pop(); gs.decreeDiscard.push(decreeId); decreesToReveal.push(decreeId); if (decreeId === 'NGAY_SONG_TRUNG') { const secondDecreeId = gs.decreeDeck.pop(); gs.decreeDiscard.push(secondDecreeId); decreesToReveal.push(secondDecreeId); } } gs.roundData.decrees = decreesToReveal.map(id => ({ ...DECREES[id], id })); io.to(roomCode).emit('decreeRevealed', { drawerName: drawer.name, decrees: gs.roundData.decrees.map(d => ({ name: d.name, description: d.description })) }); setTimeout(() => { let continueToChaos = true; for (const decree of gs.roundData.decrees) { if (decree.onReveal) { decree.onReveal(gs, io, roomCode, drawer.id); if (gs.phase === 'special_action') { continueToChaos = false; break; } } } if (continueToChaos) startChaosPhase(roomCode); }, DECREE_REVEAL_DELAY); }
function startChaosPhase(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; if (gs.roundData.decrees.some(d => d.isChaosDisabled)) { endChaosPhase(roomCode, `M·ªôt S·∫Øc L·ªánh ƒë√£ c·∫•m Giai ƒêo·∫°n H·ªón Lo·∫°n!`); return; } gs.phase = 'chaos'; io.to(roomCode).emit('chaosPhaseStarted', { duration: CHAOS_DURATION }); gs.roundData.chaosTimer = setTimeout(() => endChaosPhase(roomCode, "H·∫øt gi·ªù, kh√¥ng c√≥ h√†nh ƒë·ªông n√†o di·ªÖn ra."), CHAOS_DURATION * 1000); triggerBotChaosAction(roomCode); }
function endChaosPhase(roomCode, message) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.roundData.chaosActionTaken) return; gs.roundData.chaosActionTaken = true; gs.phase = 'reveal_pending'; clearTimeout(gs.roundData.chaosTimer); io.to(roomCode).emit('chaosActionResolved', { message }); setTimeout(() => calculateScoresAndEndRound(roomCode), 3000); }
function calculateScoresAndEndRound(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; gs.phase = 'reveal'; const { decrees, chaosResult } = gs.roundData; const results = { messages: [], scoreChanges: {}, isDraw: false, winner: null, roundWinners: [] }; let pointMultiplier = 1; decrees.forEach(d => { if(d.getPointMultiplier) pointMultiplier *= d.getPointMultiplier(); }); const active = gs.players.filter(p => !p.isDefeated); if (active.length === 0) return; const votes = { 'C·ªëng Hi·∫øn': 0, 'Tham Nh≈©ng': 0, 'Phi·∫øu Tr·ªëng': 0 }; active.forEach(p => { if (p.chosenAction) votes[p.chosenAction]++; }); if (chaosResult?.success && chaosResult.actionType === 'teamup') { if (votes[chaosResult.actionToReduce] > 0) { votes[chaosResult.actionToReduce]--; results.messages.push("ü§ù Gh√©p ƒê·ªôi th√†nh c√¥ng, m·ªôt phi·∫øu ƒë∆∞·ª£c lo·∫°i b·ªè!"); } } const { 'C·ªëng Hi·∫øn': c, 'Tham Nh≈©ng': t, 'Phi·∫øu Tr·ªëng': pt } = votes; const totalVotes = c + t + pt; let isDraw = false; if ((c === t && c > 0) || (active.length > 1 && (c === totalVotes || t === totalVotes)) || (pt > 0 && c === 0 && t === 0) || (pt > 0 && totalVotes === pt + c && t === 0) || (pt > 0 && totalVotes === pt + t && c === 0)) isDraw = true; let winner = null; if (isDraw) results.messages.push("‚öñÔ∏è K·∫øt qu·∫£: **H√íA**!"); else { const reverseDecree = decrees.find(d => d.id === 'NGAY_PHAN_XET_DAO_NGUOC'); winner = reverseDecree ? (c > t ? 'C·ªëng Hi·∫øn' : 'Tham Nh≈©ng') : (c < t ? 'C·ªëng Hi·∫øn' : 'Tham Nh≈©ng'); if (reverseDecree) results.messages.push(`üìú S·∫Øc l·ªánh 'Ng√†y Ph√°n X√©t ƒê·∫£o Ng∆∞·ª£c' c√≥ hi·ªáu l·ª±c!`); results.messages.push(`Phe **${winner}** ƒë√£ chi·∫øn th·∫Øng!`); } active.forEach(p => { let change = 0; if (isDraw) change = pt > 0 ? (p.chosenAction === 'Phi·∫øu Tr·ªëng' ? -1 : 1) : -1; else if (p.chosenAction === winner) { change = 2; results.roundWinners.push(p.id); } else if (p.chosenAction === 'Phi·∫øu Tr·ªëng') change = 3; const final = change * pointMultiplier; p.score += final; results.scoreChanges[p.id] = final; }); gs.roundData.lastScoreChanges = results.scoreChanges; decrees.forEach(d => d.endOfRoundEffect?.(gs, results, pointMultiplier)); io.to(roomCode).emit('roundResult', { players: gs.players, results, finalVoteCounts: votes }); handlePostRoundEvents(roomCode, results.roundWinners); }
function getPlayersByScore(players, type) { const a = players.filter(p => !p.isDefeated && !p.disconnected); if (a.length === 0) return []; const s = a.map(p => p.score); const c = type === 'highest' ? Math.max(...s) : Math.min(...s); return a.filter(p => p.score === c); }
function handlePlayerChoice(roomCode, playerId, choice) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'choice') return; const p = gs.players.find(p => p.id === playerId); if (p && !p.chosenAction) { p.chosenAction = choice; io.to(roomCode).emit('playerChose', playerId); } if (gs.players.filter(p => !p.isDefeated).every(p => p.chosenAction)) { clearTimeout(gs.roundData.choiceTimer); revealDecreeAndContinue(roomCode); } }
function handleChaosAction(roomCode, initiatorId, targetId, actionType, guess = null) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const i = gs.players.find(p => p.id === initiatorId), t = gs.players.find(p => p.id === targetId); if (!i || !t) return; let msg = ""; let multi = 1; gs.roundData.decrees.forEach(d => {if(d.getPointMultiplier) multi *= d.getPointMultiplier();}); if (actionType === 'challenge') { const success = guess === t.chosenAction; msg = `üî• **${i.name}** ƒë√£ Th√°ch ƒê·∫•u **${t.name}** v√† ${success ? "ƒëo√°n **ƒê√öNG**" : "ƒëo√°n **SAI**"}!`; const change = 2 * multi; if (success) { i.score += change; t.score -= change; } else { i.score -= change; t.score += change; } } else if (actionType === 'teamup') { const success = i.chosenAction === t.chosenAction; msg = `ü§ù **${i.name}** ƒë√£ Gh√©p ƒê·ªôi v·ªõi **${t.name}** v√† ${success ? "**th√†nh c√¥ng**" : "**th·∫•t b·∫°i**"}!`; if (success) gs.roundData.chaosResult = { actionType, success, actionToReduce: i.chosenAction }; else i.score -= multi; } endChaosPhase(roomCode, msg); }
function triggerRandomEvent(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs || Math.random() > 0.20) return; const events = ['avenger', 'treasury_empty']; const randomEvent = events[Math.floor(Math.random() * events.length)]; let message = ""; if (randomEvent === 'avenger') { let maxLoser = null; let maxLoss = 0; for (const id in gs.roundData.lastScoreChanges) { if (gs.roundData.lastScoreChanges[id] < maxLoss) { maxLoss = gs.roundData.lastScoreChanges[id]; maxLoser = gs.players.find(p => p.id === id); } } if (maxLoser) { maxLoser.score += 2; message = `‚öîÔ∏è **Th√≠ch Kh√°ch B√°o Th√π!** ${maxLoser.name} b·ªã tr·ª´ nhi·ªÅu ƒëi·ªÉm nh·∫•t v√† ƒë∆∞·ª£c ban th∆∞·ªüng 2 ƒëi·ªÉm an ·ªßi!`; } } else if (randomEvent === 'treasury_empty') { gs.players.forEach(p => p.score--); message = `üìâ **Ng√¢n Kh·ªë R·ªóng Tu·∫øch!** Do kh·ªßng ho·∫£ng, t·∫•t c·∫£ ng∆∞·ªùi ch∆°i b·ªã tr·ª´ 1 ƒëi·ªÉm!`; } if (message) { io.to(roomCode).emit('logMessage', { type: 'warning', message }); io.to(roomCode).emit('updateScores', gs.players.map(p => ({ id: p.id, score: p.score }))); } }
function triggerBotChoices(roomCode) { rooms[roomCode]?.gameState?.players.forEach(p => { if (p.isBot && !p.isDefeated) setTimeout(() => { if (!p.chosenAction) { let choice; switch(p.personality) { case 'aggressive': choice = Math.random() < 0.7 ? 'Tham Nh≈©ng' : 'C·ªëng Hi·∫øn'; break; case 'cautious': choice = Math.random() < 0.75 ? 'C·ªëng Hi·∫øn' : 'Phi·∫øu Tr·ªëng'; break; default: choice = ['C·ªëng Hi·∫øn', 'Tham Nh≈©ng', 'Phi·∫øu Tr·ªëng'][Math.floor(Math.random() * 3)]; } handlePlayerChoice(roomCode, p.id, choice); } }, Math.random() * 2000 + 1500); }); }
function triggerBotChaosAction(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; const bots = gs.players.filter(p => p.isBot && !p.isDefeated); const targets = gs.players.filter(p => !p.isDefeated); if (bots.length === 0 || targets.length < 2) return; bots.forEach(bot => { setTimeout(() => { if (gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const candidates = targets.filter(p => p.id !== bot.id); if (candidates.length === 0) return; const target = candidates[Math.floor(Math.random() * candidates.length)]; const actionProbability = bot.personality === 'aggressive' ? 0.6 : (bot.personality === 'cautious' ? 0.3 : 0.4); if (Math.random() < actionProbability) { const actionType = (bot.personality === 'cautious' && Math.random() < 0.8) ? 'teamup' : 'challenge'; if (actionType === 'challenge') { const guess = ['C·ªëng Hi·∫øn', 'Tham Nh≈©ng', 'Phi·∫øu Tr·ªëng'][Math.floor(Math.random() * 3)]; handleChaosAction(roomCode, bot.id, target.id, 'challenge', guess); } else { handleChaosAction(roomCode, bot.id, target.id, 'teamup'); } } else if (Math.random() < 0.5) { socket.emit('playerVotedToSkip', roomCode, bot.id); } }, Math.random() * 10000 + 5000); }); }
function handleBotAmnesia(roomCode, botId) { const gs = rooms[roomCode].gameState; const bot = gs.players.find(p => p.id === botId); io.to(roomCode).emit('logMessage', { type: 'warning', message: `üß† ${bot.name} (Bot) ƒëang s·ª≠ d·ª•ng quy·ªÅn nƒÉng c·ªßa **Ng√†y M·∫•t Tr√≠**...` }); setTimeout(() => { const activePlayers = gs.players.filter(p => !p.isDefeated); if (activePlayers.length < 2) { startChaosPhase(roomCode); return; } let p1Idx = Math.floor(Math.random() * activePlayers.length); let p2Idx; do { p2Idx = Math.floor(Math.random() * activePlayers.length); } while (p1Idx === p2Idx); const p1 = activePlayers[p1Idx], p2 = activePlayers[p2Idx]; [p1.chosenAction, p2.chosenAction] = [p2.chosenAction, p1.chosenAction]; io.to(roomCode).emit('logMessage', { type: 'warning', message: `üß† L·ª±a ch·ªçn c·ªßa **${p1.name}** v√† **${p2.name}** ƒë√£ b·ªã ho√°n ƒë·ªïi!` }); startChaosPhase(roomCode); }, 3000); }
function handleBotRomanArena(roomCode, botId) { /* T∆∞∆°ng t·ª± handleBotAmnesia */ }
function handlePostRoundEvents(roomCode, roundWinners) { const gs = rooms[roomCode].gameState; const hasLegacyWinner = gs.roundData.decrees.some(d => d.id === 'DI_SAN_CUA_KE_THANG'); if (hasLegacyWinner && roundWinners.length > 0) { const winnerId = roundWinners[Math.floor(Math.random() * roundWinners.length)]; const winner = gs.players.find(p => p.id === winnerId); if (winner.isBot) { if (gs.decreeDeck.length < 3) shuffleDecreeDeck(gs); const choice = gs.decreeDeck[Math.floor(Math.random() * 3)]; gs.nextDecree = choice; io.to(roomCode).emit('logMessage', { type: 'info', message: `${winner.name} (Bot) ƒë√£ ch·ªçn S·∫Øc L·ªánh b√≠ m·∫≠t cho v√≤ng sau.` }); } else { /* Logic cho ng∆∞·ªùi ch∆°i */ } } const W = gs.players.filter(p => p.score >= WIN_SCORE), L = gs.players.filter(p => p.score <= LOSE_SCORE); if (W.length > 0 || L.length > 0) { gs.phase = 'gameover'; io.to(roomCode).emit('gameOver', { winner: W[0], loser: L[0] }); } else { io.to(rooms[roomCode].hostId).emit('promptNextRound'); } }

io.on('connection', (socket) => { /* ... Gi·ªØ nguy√™n ... */ });

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => { console.log(`[SERVER] M√°y ch·ªß ƒëang l·∫Øng nghe tr√™n c·ªïng ${PORT}`); });