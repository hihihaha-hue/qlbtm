//======================================================================
// QUYỀN LỰC BÓNG TỐI - SERVER LOGIC (SỬA LỖI CÚ PHÁP SẮC LỆNH)
//======================================================================

const express = require('express');
const http = require('http');
const path = require('path');
const { Server } = require("socket.io");

const app = express();
const server = http.createServer(app);
const io = new Server(server, { pingInterval: 10000, pingTimeout: 5000 });
const publicPath = path.join(__dirname, 'public');
app.use(express.static(publicPath));
const rooms = {};

const CHAOS_DURATION = 30; const DECREE_REVEAL_DELAY = 5000; const WIN_SCORE = 15; const LOSE_SCORE = -15;

// [ĐÃ SỬA LỖI CÚ PHÁP]
const DECREES = {
    "NGAY_NHAN_DOI": { name: "Ngày Nhân Đôi", description: "Tất cả điểm cộng và trừ trong vòng này sẽ được nhân đôi!", getPointMultiplier: () => 2 },
    "GIO_GIOI_NGHIEM": { name: "Giờ Giới Nghiêm", description: "Vòng này cấm mọi hành vi Thách Đấu và Ghép Đội.", isChaosDisabled: true },
    "NGAY_PHAN_XET_DAO_NGUOC": { name: "Ngày Phán Xét Đảo Ngược", description: "Phe có NHIỀU phiếu hơn sẽ là phe chiến thắng!", determineWinner: (c, t) => (c === t ? null : (c > t ? 'Cống Hiến' : 'Tham Nhũng')) },
    "THUE_THAN": { name: "Thuế Thân", description: "Cuối vòng, người cao điểm nhất -2 điểm, số điểm đó được cộng cho người thấp điểm nhất.", endOfRoundEffect: (gs, results, pointMultiplier) => { const h = getPlayersByScore(gs.players, 'highest'); const l = getPlayersByScore(gs.players, 'lowest'); if (h.length > 0 && l.length > 0 && h[0].id !== l[0].id) { const tax = 2 * pointMultiplier; h.forEach(p => p.score -= tax); l.forEach(p => p.score += tax * h.length / l.length); results.messages.push(`📜 **Thuế Thân** được áp dụng!`); } } },
    "CAI_CHET_BAT_NGO": { name: "Cái Chết Bất Ngờ", description: "Nếu có người bị trừ điểm thành âm, điểm họ reset về 0, tất cả người khác -1 điểm.", endOfRoundEffect: (gs, results) => { let activated = false; const playersToReset = []; gs.players.forEach(p => { const change = results.scoreChanges[p.id] || 0; if ((p.score - change) >= 0 && p.score < 0) { playersToReset.push(p.id); activated = true; } }); if (activated) { gs.players.forEach(p => { if (playersToReset.includes(p.id)) { p.score = 0; } else { p.score--; } }); results.messages.push(`👼 Một người đã thoát khỏi âm điểm, tất cả những người khác bị trừng phạt!`); } } },
    "NGAY_TAN_THE": { name: "Ngày Tận Thế", description: "Phe thua cuộc bị chia đôi điểm số. Nếu hòa, tất cả mọi người bị chia đôi điểm số.", endOfRoundEffect: (gs, results) => { if (results.isDraw) { gs.players.forEach(p => p.score = Math.floor(p.score / 2)); results.messages.push(`💥 **Ngày Tận Thế!** Điểm của mọi người đã bị chia đôi!`); } else { gs.players.forEach(p => { if (p.chosenAction !== results.winner && p.chosenAction !== 'Phiếu Trống') { p.score = Math.floor(p.score / 2); } }); results.messages.push(`💥 **Ngày Tận Thế!** Phe thua cuộc đã bị phán xét!`); } } },
    "VU_NO_SIEU_TAN_TINH": { name: "Vụ Nổ Siêu Tân Tinh", description: "Nếu kết quả vòng này là HÒA, điểm của tất cả mọi người reset về 0!", endOfRoundEffect: (gs, results) => { if (results.isDraw) { gs.players.forEach(p => p.score = 0); results.messages.push(`💥 **VỤ NỔ SIÊU TÂN TINH!** Mọi thứ trở về vạch xuất phát!`); } } },
    "BUA_TIEC_CUA_KE_DIEN": { name: "Bữa Tiệc Của Kẻ Điên", description: "Tất cả lựa chọn sẽ được thu thập, xáo trộn và chia lại ngẫu nhiên!", isChaosDisabled: true, onReveal: (gs, io, roomCode) => { const a = gs.players.filter(p => !p.isDefeated && p.chosenAction); if (a.length < 2) return; let c = a.map(p => p.chosenAction); for (let i = c.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [c[i], c[j]] = [c[j], c[i]]; } for (let i = 0; i < a.length; i++) { a[i].chosenAction = c[i]; } io.to(roomCode).emit('actionsSwapped', { message: "🤪 Bữa tiệc của kẻ điên đã bắt đầu, lựa chọn đã bị xáo trộn!" }); } },
    "AMNESIA_DAY": { name: "Ngày Mất Trí", description: "Người thấp điểm nhất hoán đổi lựa chọn của 2 người.", onReveal: (gs, io, roomCode, drawerId) => { gs.phase = 'special_action'; const d = gs.players.find(p => p.id === drawerId); io.to(drawerId).emit('promptAmnesiaAction', { players: gs.players.map(p => ({ id: p.id, name: p.name })) }); io.to(roomCode).except(drawerId).emit('logMessage', { type: 'warning', message: `🧠 Đang chờ ${d.name} thực hiện quyền năng...`}); } },
    "LOI_THI_THAM_CUA_QUY": { name: "Lời Thì Thầm Của Quỷ", description: "Hoán đổi lựa chọn của mọi người theo vòng tròn. Thách đấu/Ghép đội bị vô hiệu.", isChaosDisabled: true, onReveal: (gs, io, roomCode) => { const a = gs.players.filter(p => !p.isDefeated && p.chosenAction); if (a.length < 2) return; const c = a.map(p => p.chosenAction); for (let i = 0; i < a.length; i++) { a[i].chosenAction = c[(i === 0) ? a.length - 1 : i - 1]; } io.to(roomCode).emit('actionsSwapped', { message: "😈 Lựa chọn của mọi người đã bị hoán đổi!" }); } },
    "KE_DANH_CAP_NGAI_VANG": { name: "Kẻ Đánh Cắp Ngai Vàng", description: "Thách đấu đúng người cao điểm nhất, bạn sẽ tráo đổi điểm số với họ." },
    "PHIEU_TRONG_DINH_MENH": { name: "Phiếu Trống Định Mệnh", description: "Phiếu Trống sẽ tự động +1 phiếu cho phe ít người hơn trước khi tính kết quả.", beforeScoring: (gs, voteCounts) => { if (voteCounts['Phiếu Trống'] > 0) { if (voteCounts['Cống Hiến'] < voteCounts['Tham Nhũng']) voteCounts['Cống Hiến'] += voteCounts['Phiếu Trống']; else if (voteCounts['Tham Nhũng'] < voteCounts['Cống Hiến']) voteCounts['Tham Nhũng'] += voteCounts['Phiếu Trống']; } } },
    "CAI_GIA_CUA_SU_THO_O": { name: "Cái Giá Của Sự Thờ Ơ", description: "Người chọn Phiếu Trống sẽ bị trừ điểm bằng số phiếu Tham Nhũng.", overrideBlankVoteScoring: true, calculateBlankVoteScore: (player, voteCounts, pointMultiplier) => { return -voteCounts['Tham Nhũng'] * pointMultiplier; } },
};
const ALL_DECREE_IDS = Object.keys(DECREES).filter(id => !DECREES[id].requiresClientUpgrade);

function createGameState(players) { return { players: players.map(p => ({ ...p, score: 0, chosenAction: null, isDefeated: false, disconnected: false })), currentRound: 0, winScore: WIN_SCORE, loseScore: LOSE_SCORE, phase: 'waiting', roundData: {}, decreeDeck: [], decreeDiscard: [] }; }
function shuffleDecreeDeck(gs) { gs.decreeDeck = [...ALL_DECREE_IDS]; for (let i = gs.decreeDeck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [gs.decreeDeck[i], gs.decreeDeck[j]] = [gs.decreeDeck[j], gs.decreeDeck[i]]; } gs.decreeDiscard = []; console.log("[SERVER] Bộ bài Sắc Lệnh đã được xáo lại."); }
function startNewRound(roomCode) { const room = rooms[roomCode]; if (!room || !room.gameState) return; const gs = room.gameState; gs.currentRound++; gs.phase = 'choice'; gs.players.forEach(p => { if (!p.isDefeated) p.chosenAction = null; }); gs.roundData = { decree: null, chaosActionTaken: false, chaosResult: null, chaosTimer: null, drawerId: null, votesToSkip: new Set() }; io.to(roomCode).emit('newRound', { roundNumber: gs.currentRound, players: gs.players.map(({ id, name, score, isDefeated, disconnected }) => ({ id, name, score, isDefeated, disconnected })) }); triggerBotChoices(roomCode); }
function revealDecreeAndContinue(roomCode) { const gs = rooms[roomCode].gameState; gs.phase = 'decree'; if (gs.currentRound === 1) { shuffleDecreeDeck(gs); io.to(roomCode).emit('logMessage', { type: 'info', message: "Vòng 1 không có Sắc Lệnh." }); startChaosPhase(roomCode); return; } if (gs.decreeDeck.length === 0) { shuffleDecreeDeck(gs); } const lowest = getPlayersByScore(gs.players, 'lowest'); const drawer = lowest[Math.floor(Math.random() * lowest.length)]; gs.roundData.drawerId = drawer.id; const decreeId = gs.decreeDeck.pop(); gs.decreeDiscard.push(decreeId); gs.roundData.decree = { ...DECREES[decreeId], id: decreeId }; io.to(roomCode).emit('decreeRevealed', { drawerName: drawer.name, decree: { name: gs.roundData.decree.name, description: gs.roundData.decree.description } }); setTimeout(() => { let continueToChaos = true; if (gs.roundData.decree.onReveal) { gs.roundData.decree.onReveal(gs, io, roomCode, drawer.id); if (gs.phase === 'special_action') { continueToChaos = false; } } if (continueToChaos) { startChaosPhase(roomCode); } }, DECREE_REVEAL_DELAY); }
function startChaosPhase(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; if (gs.roundData.decree?.isChaosDisabled) { endChaosPhase(roomCode, `Sắc lệnh '${gs.roundData.decree.name}' cấm Giai Đoạn Hỗn Loạn!`); return; } gs.phase = 'chaos'; io.to(roomCode).emit('chaosPhaseStarted', { duration: CHAOS_DURATION }); gs.roundData.chaosTimer = setTimeout(() => endChaosPhase(roomCode, "Hết giờ, không có hành động nào diễn ra."), CHAOS_DURATION * 1000); triggerBotChaosAction(roomCode); }
function endChaosPhase(roomCode, message) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.roundData.chaosActionTaken) return; gs.roundData.chaosActionTaken = true; gs.phase = 'reveal_pending'; clearTimeout(gs.roundData.chaosTimer); io.to(roomCode).emit('chaosActionResolved', { message }); setTimeout(() => calculateScoresAndEndRound(roomCode), 3000); }
function calculateScoresAndEndRound(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; gs.phase = 'reveal'; const { decree, chaosResult } = gs.roundData; const results = { messages: [], scoreChanges: {}, isDraw: false, winner: null }; const pointMultiplier = decree?.getPointMultiplier?.() || 1; const active = gs.players.filter(p => !p.isDefeated); if (active.length === 0) return; const votes = { 'Cống Hiến': 0, 'Tham Nhũng': 0, 'Phiếu Trống': 0 }; active.forEach(p => { if (p.chosenAction) votes[p.chosenAction]++; }); if (chaosResult?.success && chaosResult.actionType === 'teamup') { if (votes[chaosResult.actionToReduce] > 0) { votes[chaosResult.actionToReduce]--; results.messages.push("🤝 Ghép Đội thành công, một phiếu được loại bỏ!"); } } decree?.beforeScoring?.(gs, votes); const { 'Cống Hiến': c, 'Tham Nhũng': t, 'Phiếu Trống': pt } = votes; const totalVotes = c + t + pt; if ((c === t && c > 0) || (active.length > 1 && (c === totalVotes || t === totalVotes)) || (pt > 0 && c === 0 && t === 0) || (pt > 0 && totalVotes === pt + c && t === 0) || (pt > 0 && totalVotes === pt + t && c === 0)) { results.isDraw = true; results.messages.push("⚖️ Kết quả: **HÒA**!"); } else { results.winner = decree?.determineWinner ? decree.determineWinner(c, t) : (c < t ? 'Cống Hiến' : 'Tham Nhũng'); if (decree?.determineWinner) results.messages.push(`📜 Sắc lệnh '${decree.name}' có hiệu lực!`); results.messages.push(`Phe **${results.winner}** đã chiến thắng!`); } active.forEach(p => { let change = 0; if (p.chosenAction === 'Phiếu Trống' && decree?.overrideBlankVoteScoring) { change = decree.calculateBlankVoteScore(p, votes, pointMultiplier); } else { if (results.isDraw) change = pt > 0 ? (p.chosenAction === 'Phiếu Trống' ? -1 : 1) : -1; else if (p.chosenAction === results.winner) change = 2; else if (p.chosenAction === 'Phiếu Trống') change = 3; } results.scoreChanges[p.id] = change * pointMultiplier; }); active.forEach(p => p.score += (results.scoreChanges[p.id] || 0)); if (decree?.endOfRoundEffect) { decree.endOfRoundEffect(gs, results, pointMultiplier); } io.to(roomCode).emit('roundResult', { players: gs.players, results, finalVoteCounts: votes }); const W = gs.players.filter(p => p.score >= WIN_SCORE), L = gs.players.filter(p => p.score <= LOSE_SCORE); if (W.length > 0 || L.length > 0) { gs.phase = 'gameover'; io.to(roomCode).emit('gameOver', { winner: W[0], loser: L[0] }); } else io.to(rooms[roomCode].hostId).emit('promptNextRound'); }
function getPlayersByScore(players, type) { const a = players.filter(p => !p.isDefeated && !p.disconnected); if (a.length === 0) return []; const s = a.map(p => p.score); const c = type === 'highest' ? Math.max(...s) : Math.min(...s); return a.filter(p => p.score === c); }
function triggerBotChoices(roomCode) { rooms[roomCode]?.gameState?.players.forEach(p => { if (p.isBot && !p.isDefeated) setTimeout(() => { let choice; switch(p.personality) { case 'aggressive': choice = Math.random() < 0.6 ? 'Tham Nhũng' : 'Cống Hiến'; break; case 'cautious': choice = Math.random() < 0.7 ? 'Cống Hiến' : 'Phiếu Trống'; break; default: choice = ['Cống Hiến', 'Tham Nhũng', 'Phiếu Trống'][Math.floor(Math.random() * 3)]; } handlePlayerChoice(roomCode, p.id, choice); }, Math.random() * 2000 + 1500); }); }
function triggerBotChaosAction(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; const bots = gs.players.filter(p => p.isBot && !p.isDefeated); const targets = gs.players.filter(p => !p.isDefeated); if (bots.length === 0 || targets.length < 2) return; bots.forEach(bot => { setTimeout(() => { if (gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const candidates = targets.filter(p => p.id !== bot.id); if (candidates.length === 0) return; const target = candidates[Math.floor(Math.random() * candidates.length)]; switch(bot.personality) { case 'aggressive': if (Math.random() < 0.5) { const guess = ['Cống Hiến', 'Tham Nhũng', 'Phiếu Trống'][Math.floor(Math.random() * 3)]; handleChaosAction(roomCode, bot.id, target.id, 'challenge', guess); } break; case 'cautious': if (Math.random() < 0.3) { handleChaosAction(roomCode, bot.id, target.id, 'teamup'); } break; } }, Math.random() * 10000 + 5000); }); }
function handlePlayerChoice(roomCode, playerId, choice) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'choice') return; const p = gs.players.find(p => p.id === playerId); if (p && !p.chosenAction) { p.chosenAction = choice; io.to(roomCode).emit('playerChose', playerId); } if (gs.players.filter(p => !p.isDefeated).every(p => p.chosenAction)) { revealDecreeAndContinue(roomCode); } }
function handleChaosAction(roomCode, initiatorId, targetId, actionType, guess = null) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const initiator = gs.players.find(p => p.id === initiatorId), target = gs.players.find(p => p.id === targetId); if (!initiator || !target) return; let msg = ""; const multi = gs.roundData.decree?.getPointMultiplier?.() || 1; if (actionType === 'challenge') { const success = guess === target.chosenAction; const isThroneStealAttempt = (gs.roundData.decree?.id === 'KE_DANH_CAP_NGAI_VANG'); const targetIsHighest = getPlayersByScore(gs.players, 'highest').some(p => p.id === targetId); if (success && isThroneStealAttempt && targetIsHighest) { msg = `👑 **${initiator.name}** đã thực hiện một vụ ĐÁNH CẮP NGAY VÀNG ngoạn mục!`; [initiator.score, target.score] = [target.score, initiator.score]; } else { msg = `🔥 **${initiator.name}** đã Thách Đấu **${target.name}** và ${success ? "đoán **ĐÚNG**" : "đoán **SAI**"}!`; const change = 2 * multi; if (success) { initiator.score += change; target.score -= change; } else { initiator.score -= change; target.score += change; } } } else if (actionType === 'teamup') { const success = initiator.chosenAction === target.chosenAction; msg = `🤝 **${initiator.name}** đã Ghép Đội với **${target.name}** và ${success ? "**thành công**" : "**thất bại**"}!`; if (success) gs.roundData.chaosResult = { actionType, success, actionToReduce: initiator.chosenAction }; else initiator.score -= multi; } endChaosPhase(roomCode, msg); }
io.on('connection', (socket) => { socket.on('createRoom', data => { let code; do { code = Math.random().toString(36).substring(2, 6).toUpperCase(); } while (rooms[code]); rooms[code] = { players: [], hostId: socket.id, maxPlayers: 6, gameState: null }; handleJoinRoom(code, data.name); }); socket.on('joinRoom', data => handleJoinRoom(data.roomCode?.trim().toUpperCase(), data.name)); function handleJoinRoom(code, name) { const room = rooms[code]; if (!room) return socket.emit('roomError', `Phòng '${code}' không tồn tại!`); if (room.gameState) return socket.emit('roomError', 'Trò chơi đã bắt đầu!'); if (room.players.length >= room.maxPlayers) return socket.emit('roomError', 'Phòng đã đầy!'); const p = { id: socket.id, name: (name || `Người chơi ${room.players.length + 1}`).substring(0, 15).trim(), isBot: false }; room.players.push(p); socket.join(code); io.to(code).emit('updatePlayerList', room.players, room.hostId); socket.emit('joinedRoom', { roomCode: code, hostId: room.hostId, myId: socket.id, players: room.players }); } socket.on('addBot', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.players.length < r.maxPlayers) { const personalities = ['aggressive', 'cautious', 'random']; const p = { id: `bot-${Date.now()}`, name: `Bot ${r.players.length + 1}`, isBot: true, personality: personalities[Math.floor(Math.random() * personalities.length)] }; r.players.push(p); io.to(code).emit('updatePlayerList', r.players, r.hostId); } }); socket.on('changeName', data => { const p = rooms[data.roomCode]?.players.find(p => p.id === socket.id); if (p) { p.name = data.newName.substring(0, 15).trim() || p.name; io.to(data.roomCode).emit('updatePlayerList', rooms[data.roomCode].players, rooms[data.roomCode].hostId); } }); socket.on('startGame', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.players.length >= 2) { r.gameState = createGameState(r.players); io.to(code).emit('gameStarted'); startNewRound(code); } }); socket.on('playerChoice', data => handlePlayerChoice(data.roomCode, socket.id, data.choice)); socket.on('requestChaosAction', data => handleChaosAction(data.roomCode, socket.id, data.targetId, data.actionType, data.guess)); socket.on('playerVotedToSkip', (roomCode) => { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; gs.roundData.votesToSkip.add(socket.id); const activeHumanPlayers = gs.players.filter(p => !p.isBot && !p.disconnected).length; io.to(roomCode).emit('updateSkipVoteCount', gs.roundData.votesToSkip.size, activeHumanPlayers); if (gs.roundData.votesToSkip.size >= activeHumanPlayers) { endChaosPhase(roomCode, "Tất cả người chơi đã đồng ý bỏ qua giai đoạn này."); } }); socket.on('amnesiaAction', data => { const gs = rooms[data.roomCode]?.gameState; if (!gs || gs.phase !== 'special_action') return; const p1 = gs.players.find(p => p.id === data.player1Id), p2 = gs.players.find(p => p.id === data.player2Id); if (p1 && p2) { [p1.chosenAction, p2.chosenAction] = [p2.chosenAction, p1.chosenAction]; io.to(data.roomCode).emit('logMessage', { type: 'warning', message: `🧠 Lựa chọn của **${p1.name}** và **${p2.name}** đã bị hoán đổi!` }); } startChaosPhase(data.roomCode); }); socket.on('nextRound', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.gameState.phase !== 'gameover') startNewRound(code); }); socket.on('disconnect', () => { for (const code in rooms) { const r = rooms[code]; const i = r.players.findIndex(p => p.id === socket.id); if (i !== -1) { if (r.gameState) { const p = r.gameState.players.find(p => p.id === socket.id); if (p) { p.disconnected = true; p.name = `${p.name} (Rời trận)`; io.to(code).emit('playerDisconnected', { playerId: socket.id, newName: p.name }); } } else r.players.splice(i, 1); if (r.players.filter(p => !p.isBot).length === 0) { delete rooms[code]; break; } if (socket.id === r.hostId && r.players.length > 0) { r.hostId = (r.players.find(p => !p.isBot) || r.players[0]).id; } io.to(code).emit('updatePlayerList', r.players, r.hostId); break; } } }); });

const PORT = process.env.PORT || 3000;
const HOST = '0.0.0.0';
//======================================================================
// VI. KHỞI ĐỘNG MÁY CHỦ
//======================================================================
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`[SERVER] Máy chủ đang lắng nghe trên cổng ${PORT}`);
});