//======================================================================
// QUY·ªÄN L·ª∞C B√ìNG T·ªêI - SERVER LOGIC (S·ª¨A L·ªñI C√ö PH√ÅP S·∫ÆC L·ªÜNH)
//======================================================================

const express = require('express');
const http = require('http');
const path = require('path');
const { Server } = require("socket.io");

const app = express();
const server = http.createServer(app);
const io = new Server(server, { pingInterval: 10000, pingTimeout: 5000 });
const publicPath = path.join(__dirname, 'public');
app.use(express.static(publicPath));
const rooms = {};

const CHAOS_DURATION = 30; const DECREE_REVEAL_DELAY = 5000; const WIN_SCORE = 15; const LOSE_SCORE = -15;

// [ƒê√É S·ª¨A L·ªñI C√ö PH√ÅP]
const DECREES = {
    "NGAY_NHAN_DOI": { name: "Ng√†y Nh√¢n ƒê√¥i", description: "T·∫•t c·∫£ ƒëi·ªÉm c·ªông v√† tr·ª´ trong v√≤ng n√†y s·∫Ω ƒë∆∞·ª£c nh√¢n ƒë√¥i!", getPointMultiplier: () => 2 },
    "GIO_GIOI_NGHIEM": { name: "Gi·ªù Gi·ªõi Nghi√™m", description: "V√≤ng n√†y c·∫•m m·ªçi h√†nh vi Th√°ch ƒê·∫•u v√† Gh√©p ƒê·ªôi.", isChaosDisabled: true },
    "NGAY_PHAN_XET_DAO_NGUOC": { name: "Ng√†y Ph√°n X√©t ƒê·∫£o Ng∆∞·ª£c", description: "Phe c√≥ NHI·ªÄU phi·∫øu h∆°n s·∫Ω l√† phe chi·∫øn th·∫Øng!", determineWinner: (c, t) => (c === t ? null : (c > t ? 'C·ªëng Hi·∫øn' : 'Tham Nh≈©ng')) },
    "THUE_THAN": { name: "Thu·∫ø Th√¢n", description: "Cu·ªëi v√≤ng, ng∆∞·ªùi cao ƒëi·ªÉm nh·∫•t -2 ƒëi·ªÉm, s·ªë ƒëi·ªÉm ƒë√≥ ƒë∆∞·ª£c c·ªông cho ng∆∞·ªùi th·∫•p ƒëi·ªÉm nh·∫•t.", endOfRoundEffect: (gs, results, pointMultiplier) => { const h = getPlayersByScore(gs.players, 'highest'); const l = getPlayersByScore(gs.players, 'lowest'); if (h.length > 0 && l.length > 0 && h[0].id !== l[0].id) { const tax = 2 * pointMultiplier; h.forEach(p => p.score -= tax); l.forEach(p => p.score += tax * h.length / l.length); results.messages.push(`üìú **Thu·∫ø Th√¢n** ƒë∆∞·ª£c √°p d·ª•ng!`); } } },
    "CAI_CHET_BAT_NGO": { name: "C√°i Ch·∫øt B·∫•t Ng·ªù", description: "N·∫øu c√≥ ng∆∞·ªùi b·ªã tr·ª´ ƒëi·ªÉm th√†nh √¢m, ƒëi·ªÉm h·ªç reset v·ªÅ 0, t·∫•t c·∫£ ng∆∞·ªùi kh√°c -1 ƒëi·ªÉm.", endOfRoundEffect: (gs, results) => { let activated = false; const playersToReset = []; gs.players.forEach(p => { const change = results.scoreChanges[p.id] || 0; if ((p.score - change) >= 0 && p.score < 0) { playersToReset.push(p.id); activated = true; } }); if (activated) { gs.players.forEach(p => { if (playersToReset.includes(p.id)) { p.score = 0; } else { p.score--; } }); results.messages.push(`üëº M·ªôt ng∆∞·ªùi ƒë√£ tho√°t kh·ªèi √¢m ƒëi·ªÉm, t·∫•t c·∫£ nh·ªØng ng∆∞·ªùi kh√°c b·ªã tr·ª´ng ph·∫°t!`); } } },
    "NGAY_TAN_THE": { name: "Ng√†y T·∫≠n Th·∫ø", description: "Phe thua cu·ªôc b·ªã chia ƒë√¥i ƒëi·ªÉm s·ªë. N·∫øu h√≤a, t·∫•t c·∫£ m·ªçi ng∆∞·ªùi b·ªã chia ƒë√¥i ƒëi·ªÉm s·ªë.", endOfRoundEffect: (gs, results) => { if (results.isDraw) { gs.players.forEach(p => p.score = Math.floor(p.score / 2)); results.messages.push(`üí• **Ng√†y T·∫≠n Th·∫ø!** ƒêi·ªÉm c·ªßa m·ªçi ng∆∞·ªùi ƒë√£ b·ªã chia ƒë√¥i!`); } else { gs.players.forEach(p => { if (p.chosenAction !== results.winner && p.chosenAction !== 'Phi·∫øu Tr·ªëng') { p.score = Math.floor(p.score / 2); } }); results.messages.push(`üí• **Ng√†y T·∫≠n Th·∫ø!** Phe thua cu·ªôc ƒë√£ b·ªã ph√°n x√©t!`); } } },
    "VU_NO_SIEU_TAN_TINH": { name: "V·ª• N·ªï Si√™u T√¢n Tinh", description: "N·∫øu k·∫øt qu·∫£ v√≤ng n√†y l√† H√íA, ƒëi·ªÉm c·ªßa t·∫•t c·∫£ m·ªçi ng∆∞·ªùi reset v·ªÅ 0!", endOfRoundEffect: (gs, results) => { if (results.isDraw) { gs.players.forEach(p => p.score = 0); results.messages.push(`üí• **V·ª§ N·ªî SI√äU T√ÇN TINH!** M·ªçi th·ª© tr·ªü v·ªÅ v·∫°ch xu·∫•t ph√°t!`); } } },
    "BUA_TIEC_CUA_KE_DIEN": { name: "B·ªØa Ti·ªác C·ªßa K·∫ª ƒêi√™n", description: "T·∫•t c·∫£ l·ª±a ch·ªçn s·∫Ω ƒë∆∞·ª£c thu th·∫≠p, x√°o tr·ªôn v√† chia l·∫°i ng·∫´u nhi√™n!", isChaosDisabled: true, onReveal: (gs, io, roomCode) => { const a = gs.players.filter(p => !p.isDefeated && p.chosenAction); if (a.length < 2) return; let c = a.map(p => p.chosenAction); for (let i = c.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [c[i], c[j]] = [c[j], c[i]]; } for (let i = 0; i < a.length; i++) { a[i].chosenAction = c[i]; } io.to(roomCode).emit('actionsSwapped', { message: "ü§™ B·ªØa ti·ªác c·ªßa k·∫ª ƒëi√™n ƒë√£ b·∫Øt ƒë·∫ßu, l·ª±a ch·ªçn ƒë√£ b·ªã x√°o tr·ªôn!" }); } },
    "AMNESIA_DAY": { name: "Ng√†y M·∫•t Tr√≠", description: "Ng∆∞·ªùi th·∫•p ƒëi·ªÉm nh·∫•t ho√°n ƒë·ªïi l·ª±a ch·ªçn c·ªßa 2 ng∆∞·ªùi.", onReveal: (gs, io, roomCode, drawerId) => { gs.phase = 'special_action'; const d = gs.players.find(p => p.id === drawerId); io.to(drawerId).emit('promptAmnesiaAction', { players: gs.players.map(p => ({ id: p.id, name: p.name })) }); io.to(roomCode).except(drawerId).emit('logMessage', { type: 'warning', message: `üß† ƒêang ch·ªù ${d.name} th·ª±c hi·ªán quy·ªÅn nƒÉng...`}); } },
    "LOI_THI_THAM_CUA_QUY": { name: "L·ªùi Th√¨ Th·∫ßm C·ªßa Qu·ª∑", description: "Ho√°n ƒë·ªïi l·ª±a ch·ªçn c·ªßa m·ªçi ng∆∞·ªùi theo v√≤ng tr√≤n. Th√°ch ƒë·∫•u/Gh√©p ƒë·ªôi b·ªã v√¥ hi·ªáu.", isChaosDisabled: true, onReveal: (gs, io, roomCode) => { const a = gs.players.filter(p => !p.isDefeated && p.chosenAction); if (a.length < 2) return; const c = a.map(p => p.chosenAction); for (let i = 0; i < a.length; i++) { a[i].chosenAction = c[(i === 0) ? a.length - 1 : i - 1]; } io.to(roomCode).emit('actionsSwapped', { message: "üòà L·ª±a ch·ªçn c·ªßa m·ªçi ng∆∞·ªùi ƒë√£ b·ªã ho√°n ƒë·ªïi!" }); } },
    "KE_DANH_CAP_NGAI_VANG": { name: "K·∫ª ƒê√°nh C·∫Øp Ngai V√†ng", description: "Th√°ch ƒë·∫•u ƒë√∫ng ng∆∞·ªùi cao ƒëi·ªÉm nh·∫•t, b·∫°n s·∫Ω tr√°o ƒë·ªïi ƒëi·ªÉm s·ªë v·ªõi h·ªç." },
    "PHIEU_TRONG_DINH_MENH": { name: "Phi·∫øu Tr·ªëng ƒê·ªãnh M·ªánh", description: "Phi·∫øu Tr·ªëng s·∫Ω t·ª± ƒë·ªông +1 phi·∫øu cho phe √≠t ng∆∞·ªùi h∆°n tr∆∞·ªõc khi t√≠nh k·∫øt qu·∫£.", beforeScoring: (gs, voteCounts) => { if (voteCounts['Phi·∫øu Tr·ªëng'] > 0) { if (voteCounts['C·ªëng Hi·∫øn'] < voteCounts['Tham Nh≈©ng']) voteCounts['C·ªëng Hi·∫øn'] += voteCounts['Phi·∫øu Tr·ªëng']; else if (voteCounts['Tham Nh≈©ng'] < voteCounts['C·ªëng Hi·∫øn']) voteCounts['Tham Nh≈©ng'] += voteCounts['Phi·∫øu Tr·ªëng']; } } },
    "CAI_GIA_CUA_SU_THO_O": { name: "C√°i Gi√° C·ªßa S·ª± Th·ªù ∆†", description: "Ng∆∞·ªùi ch·ªçn Phi·∫øu Tr·ªëng s·∫Ω b·ªã tr·ª´ ƒëi·ªÉm b·∫±ng s·ªë phi·∫øu Tham Nh≈©ng.", overrideBlankVoteScoring: true, calculateBlankVoteScore: (player, voteCounts, pointMultiplier) => { return -voteCounts['Tham Nh≈©ng'] * pointMultiplier; } },
};
const ALL_DECREE_IDS = Object.keys(DECREES).filter(id => !DECREES[id].requiresClientUpgrade);

function createGameState(players) { return { players: players.map(p => ({ ...p, score: 0, chosenAction: null, isDefeated: false, disconnected: false })), currentRound: 0, winScore: WIN_SCORE, loseScore: LOSE_SCORE, phase: 'waiting', roundData: {}, decreeDeck: [], decreeDiscard: [] }; }
function shuffleDecreeDeck(gs) { gs.decreeDeck = [...ALL_DECREE_IDS]; for (let i = gs.decreeDeck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [gs.decreeDeck[i], gs.decreeDeck[j]] = [gs.decreeDeck[j], gs.decreeDeck[i]]; } gs.decreeDiscard = []; console.log("[SERVER] B·ªô b√†i S·∫Øc L·ªánh ƒë√£ ƒë∆∞·ª£c x√°o l·∫°i."); }
function startNewRound(roomCode) { const room = rooms[roomCode]; if (!room || !room.gameState) return; const gs = room.gameState; gs.currentRound++; gs.phase = 'choice'; gs.players.forEach(p => { if (!p.isDefeated) p.chosenAction = null; }); gs.roundData = { decree: null, chaosActionTaken: false, chaosResult: null, chaosTimer: null, drawerId: null, votesToSkip: new Set() }; io.to(roomCode).emit('newRound', { roundNumber: gs.currentRound, players: gs.players.map(({ id, name, score, isDefeated, disconnected }) => ({ id, name, score, isDefeated, disconnected })) }); triggerBotChoices(roomCode); }
function revealDecreeAndContinue(roomCode) { const gs = rooms[roomCode].gameState; gs.phase = 'decree'; if (gs.currentRound === 1) { shuffleDecreeDeck(gs); io.to(roomCode).emit('logMessage', { type: 'info', message: "V√≤ng 1 kh√¥ng c√≥ S·∫Øc L·ªánh." }); startChaosPhase(roomCode); return; } if (gs.decreeDeck.length === 0) { shuffleDecreeDeck(gs); } const lowest = getPlayersByScore(gs.players, 'lowest'); const drawer = lowest[Math.floor(Math.random() * lowest.length)]; gs.roundData.drawerId = drawer.id; const decreeId = gs.decreeDeck.pop(); gs.decreeDiscard.push(decreeId); gs.roundData.decree = { ...DECREES[decreeId], id: decreeId }; io.to(roomCode).emit('decreeRevealed', { drawerName: drawer.name, decree: { name: gs.roundData.decree.name, description: gs.roundData.decree.description } }); setTimeout(() => { let continueToChaos = true; if (gs.roundData.decree.onReveal) { gs.roundData.decree.onReveal(gs, io, roomCode, drawer.id); if (gs.phase === 'special_action') { continueToChaos = false; } } if (continueToChaos) { startChaosPhase(roomCode); } }, DECREE_REVEAL_DELAY); }
function startChaosPhase(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; if (gs.roundData.decree?.isChaosDisabled) { endChaosPhase(roomCode, `S·∫Øc l·ªánh '${gs.roundData.decree.name}' c·∫•m Giai ƒêo·∫°n H·ªón Lo·∫°n!`); return; } gs.phase = 'chaos'; io.to(roomCode).emit('chaosPhaseStarted', { duration: CHAOS_DURATION }); gs.roundData.chaosTimer = setTimeout(() => endChaosPhase(roomCode, "H·∫øt gi·ªù, kh√¥ng c√≥ h√†nh ƒë·ªông n√†o di·ªÖn ra."), CHAOS_DURATION * 1000); triggerBotChaosAction(roomCode); }
function endChaosPhase(roomCode, message) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.roundData.chaosActionTaken) return; gs.roundData.chaosActionTaken = true; gs.phase = 'reveal_pending'; clearTimeout(gs.roundData.chaosTimer); io.to(roomCode).emit('chaosActionResolved', { message }); setTimeout(() => calculateScoresAndEndRound(roomCode), 3000); }
function calculateScoresAndEndRound(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; gs.phase = 'reveal'; const { decree, chaosResult } = gs.roundData; const results = { messages: [], scoreChanges: {}, isDraw: false, winner: null }; const pointMultiplier = decree?.getPointMultiplier?.() || 1; const active = gs.players.filter(p => !p.isDefeated); if (active.length === 0) return; const votes = { 'C·ªëng Hi·∫øn': 0, 'Tham Nh≈©ng': 0, 'Phi·∫øu Tr·ªëng': 0 }; active.forEach(p => { if (p.chosenAction) votes[p.chosenAction]++; }); if (chaosResult?.success && chaosResult.actionType === 'teamup') { if (votes[chaosResult.actionToReduce] > 0) { votes[chaosResult.actionToReduce]--; results.messages.push("ü§ù Gh√©p ƒê·ªôi th√†nh c√¥ng, m·ªôt phi·∫øu ƒë∆∞·ª£c lo·∫°i b·ªè!"); } } decree?.beforeScoring?.(gs, votes); const { 'C·ªëng Hi·∫øn': c, 'Tham Nh≈©ng': t, 'Phi·∫øu Tr·ªëng': pt } = votes; const totalVotes = c + t + pt; if ((c === t && c > 0) || (active.length > 1 && (c === totalVotes || t === totalVotes)) || (pt > 0 && c === 0 && t === 0) || (pt > 0 && totalVotes === pt + c && t === 0) || (pt > 0 && totalVotes === pt + t && c === 0)) { results.isDraw = true; results.messages.push("‚öñÔ∏è K·∫øt qu·∫£: **H√íA**!"); } else { results.winner = decree?.determineWinner ? decree.determineWinner(c, t) : (c < t ? 'C·ªëng Hi·∫øn' : 'Tham Nh≈©ng'); if (decree?.determineWinner) results.messages.push(`üìú S·∫Øc l·ªánh '${decree.name}' c√≥ hi·ªáu l·ª±c!`); results.messages.push(`Phe **${results.winner}** ƒë√£ chi·∫øn th·∫Øng!`); } active.forEach(p => { let change = 0; if (p.chosenAction === 'Phi·∫øu Tr·ªëng' && decree?.overrideBlankVoteScoring) { change = decree.calculateBlankVoteScore(p, votes, pointMultiplier); } else { if (results.isDraw) change = pt > 0 ? (p.chosenAction === 'Phi·∫øu Tr·ªëng' ? -1 : 1) : -1; else if (p.chosenAction === results.winner) change = 2; else if (p.chosenAction === 'Phi·∫øu Tr·ªëng') change = 3; } results.scoreChanges[p.id] = change * pointMultiplier; }); active.forEach(p => p.score += (results.scoreChanges[p.id] || 0)); if (decree?.endOfRoundEffect) { decree.endOfRoundEffect(gs, results, pointMultiplier); } io.to(roomCode).emit('roundResult', { players: gs.players, results, finalVoteCounts: votes }); const W = gs.players.filter(p => p.score >= WIN_SCORE), L = gs.players.filter(p => p.score <= LOSE_SCORE); if (W.length > 0 || L.length > 0) { gs.phase = 'gameover'; io.to(roomCode).emit('gameOver', { winner: W[0], loser: L[0] }); } else io.to(rooms[roomCode].hostId).emit('promptNextRound'); }
function getPlayersByScore(players, type) { const a = players.filter(p => !p.isDefeated && !p.disconnected); if (a.length === 0) return []; const s = a.map(p => p.score); const c = type === 'highest' ? Math.max(...s) : Math.min(...s); return a.filter(p => p.score === c); }
function triggerBotChoices(roomCode) { rooms[roomCode]?.gameState?.players.forEach(p => { if (p.isBot && !p.isDefeated) setTimeout(() => { let choice; switch(p.personality) { case 'aggressive': choice = Math.random() < 0.6 ? 'Tham Nh≈©ng' : 'C·ªëng Hi·∫øn'; break; case 'cautious': choice = Math.random() < 0.7 ? 'C·ªëng Hi·∫øn' : 'Phi·∫øu Tr·ªëng'; break; default: choice = ['C·ªëng Hi·∫øn', 'Tham Nh≈©ng', 'Phi·∫øu Tr·ªëng'][Math.floor(Math.random() * 3)]; } handlePlayerChoice(roomCode, p.id, choice); }, Math.random() * 2000 + 1500); }); }
function triggerBotChaosAction(roomCode) { const gs = rooms[roomCode]?.gameState; if (!gs) return; const bots = gs.players.filter(p => p.isBot && !p.isDefeated); const targets = gs.players.filter(p => !p.isDefeated); if (bots.length === 0 || targets.length < 2) return; bots.forEach(bot => { setTimeout(() => { if (gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const candidates = targets.filter(p => p.id !== bot.id); if (candidates.length === 0) return; const target = candidates[Math.floor(Math.random() * candidates.length)]; switch(bot.personality) { case 'aggressive': if (Math.random() < 0.5) { const guess = ['C·ªëng Hi·∫øn', 'Tham Nh≈©ng', 'Phi·∫øu Tr·ªëng'][Math.floor(Math.random() * 3)]; handleChaosAction(roomCode, bot.id, target.id, 'challenge', guess); } break; case 'cautious': if (Math.random() < 0.3) { handleChaosAction(roomCode, bot.id, target.id, 'teamup'); } break; } }, Math.random() * 10000 + 5000); }); }
function handlePlayerChoice(roomCode, playerId, choice) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'choice') return; const p = gs.players.find(p => p.id === playerId); if (p && !p.chosenAction) { p.chosenAction = choice; io.to(roomCode).emit('playerChose', playerId); } if (gs.players.filter(p => !p.isDefeated).every(p => p.chosenAction)) { revealDecreeAndContinue(roomCode); } }
function handleChaosAction(roomCode, initiatorId, targetId, actionType, guess = null) { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; const initiator = gs.players.find(p => p.id === initiatorId), target = gs.players.find(p => p.id === targetId); if (!initiator || !target) return; let msg = ""; const multi = gs.roundData.decree?.getPointMultiplier?.() || 1; if (actionType === 'challenge') { const success = guess === target.chosenAction; const isThroneStealAttempt = (gs.roundData.decree?.id === 'KE_DANH_CAP_NGAI_VANG'); const targetIsHighest = getPlayersByScore(gs.players, 'highest').some(p => p.id === targetId); if (success && isThroneStealAttempt && targetIsHighest) { msg = `üëë **${initiator.name}** ƒë√£ th·ª±c hi·ªán m·ªôt v·ª• ƒê√ÅNH C·∫ÆP NGAY V√ÄNG ngo·∫°n m·ª•c!`; [initiator.score, target.score] = [target.score, initiator.score]; } else { msg = `üî• **${initiator.name}** ƒë√£ Th√°ch ƒê·∫•u **${target.name}** v√† ${success ? "ƒëo√°n **ƒê√öNG**" : "ƒëo√°n **SAI**"}!`; const change = 2 * multi; if (success) { initiator.score += change; target.score -= change; } else { initiator.score -= change; target.score += change; } } } else if (actionType === 'teamup') { const success = initiator.chosenAction === target.chosenAction; msg = `ü§ù **${initiator.name}** ƒë√£ Gh√©p ƒê·ªôi v·ªõi **${target.name}** v√† ${success ? "**th√†nh c√¥ng**" : "**th·∫•t b·∫°i**"}!`; if (success) gs.roundData.chaosResult = { actionType, success, actionToReduce: initiator.chosenAction }; else initiator.score -= multi; } endChaosPhase(roomCode, msg); }
io.on('connection', (socket) => { socket.on('createRoom', data => { let code; do { code = Math.random().toString(36).substring(2, 6).toUpperCase(); } while (rooms[code]); rooms[code] = { players: [], hostId: socket.id, maxPlayers: 6, gameState: null }; handleJoinRoom(code, data.name); }); socket.on('joinRoom', data => handleJoinRoom(data.roomCode?.trim().toUpperCase(), data.name)); function handleJoinRoom(code, name) { const room = rooms[code]; if (!room) return socket.emit('roomError', `Ph√≤ng '${code}' kh√¥ng t·ªìn t·∫°i!`); if (room.gameState) return socket.emit('roomError', 'Tr√≤ ch∆°i ƒë√£ b·∫Øt ƒë·∫ßu!'); if (room.players.length >= room.maxPlayers) return socket.emit('roomError', 'Ph√≤ng ƒë√£ ƒë·∫ßy!'); const p = { id: socket.id, name: (name || `Ng∆∞·ªùi ch∆°i ${room.players.length + 1}`).substring(0, 15).trim(), isBot: false }; room.players.push(p); socket.join(code); io.to(code).emit('updatePlayerList', room.players, room.hostId); socket.emit('joinedRoom', { roomCode: code, hostId: room.hostId, myId: socket.id, players: room.players }); } socket.on('addBot', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.players.length < r.maxPlayers) { const personalities = ['aggressive', 'cautious', 'random']; const p = { id: `bot-${Date.now()}`, name: `Bot ${r.players.length + 1}`, isBot: true, personality: personalities[Math.floor(Math.random() * personalities.length)] }; r.players.push(p); io.to(code).emit('updatePlayerList', r.players, r.hostId); } }); socket.on('changeName', data => { const p = rooms[data.roomCode]?.players.find(p => p.id === socket.id); if (p) { p.name = data.newName.substring(0, 15).trim() || p.name; io.to(data.roomCode).emit('updatePlayerList', rooms[data.roomCode].players, rooms[data.roomCode].hostId); } }); socket.on('startGame', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.players.length >= 2) { r.gameState = createGameState(r.players); io.to(code).emit('gameStarted'); startNewRound(code); } }); socket.on('playerChoice', data => handlePlayerChoice(data.roomCode, socket.id, data.choice)); socket.on('requestChaosAction', data => handleChaosAction(data.roomCode, socket.id, data.targetId, data.actionType, data.guess)); socket.on('playerVotedToSkip', (roomCode) => { const gs = rooms[roomCode]?.gameState; if (!gs || gs.phase !== 'chaos' || gs.roundData.chaosActionTaken) return; gs.roundData.votesToSkip.add(socket.id); const activeHumanPlayers = gs.players.filter(p => !p.isBot && !p.disconnected).length; io.to(roomCode).emit('updateSkipVoteCount', gs.roundData.votesToSkip.size, activeHumanPlayers); if (gs.roundData.votesToSkip.size >= activeHumanPlayers) { endChaosPhase(roomCode, "T·∫•t c·∫£ ng∆∞·ªùi ch∆°i ƒë√£ ƒë·ªìng √Ω b·ªè qua giai ƒëo·∫°n n√†y."); } }); socket.on('amnesiaAction', data => { const gs = rooms[data.roomCode]?.gameState; if (!gs || gs.phase !== 'special_action') return; const p1 = gs.players.find(p => p.id === data.player1Id), p2 = gs.players.find(p => p.id === data.player2Id); if (p1 && p2) { [p1.chosenAction, p2.chosenAction] = [p2.chosenAction, p1.chosenAction]; io.to(data.roomCode).emit('logMessage', { type: 'warning', message: `üß† L·ª±a ch·ªçn c·ªßa **${p1.name}** v√† **${p2.name}** ƒë√£ b·ªã ho√°n ƒë·ªïi!` }); } startChaosPhase(data.roomCode); }); socket.on('nextRound', code => { const r = rooms[code]; if (r && socket.id === r.hostId && r.gameState.phase !== 'gameover') startNewRound(code); }); socket.on('disconnect', () => { for (const code in rooms) { const r = rooms[code]; const i = r.players.findIndex(p => p.id === socket.id); if (i !== -1) { if (r.gameState) { const p = r.gameState.players.find(p => p.id === socket.id); if (p) { p.disconnected = true; p.name = `${p.name} (R·ªùi tr·∫≠n)`; io.to(code).emit('playerDisconnected', { playerId: socket.id, newName: p.name }); } } else r.players.splice(i, 1); if (r.players.filter(p => !p.isBot).length === 0) { delete rooms[code]; break; } if (socket.id === r.hostId && r.players.length > 0) { r.hostId = (r.players.find(p => !p.isBot) || r.players[0]).id; } io.to(code).emit('updatePlayerList', r.players, r.hostId); break; } } }); });

const PORT = process.env.PORT || 3000;
const HOST = '0.0.0.0';
//======================================================================
// VI. KH·ªûI ƒê·ªòNG M√ÅY CH·ª¶
//======================================================================
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`[SERVER] M√°y ch·ªß ƒëang l·∫Øng nghe tr√™n c·ªïng ${PORT}`);
});